{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n\n  try {\n    var ast = getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n\n      PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n\n  return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n\n      break;\n\n    case \"Alternative\":\n      var terms = ast.value;\n\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i]; // skip terms that cannot effect the first char results\n\n        switch (term.type) {\n          case \"EndAnchor\": // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n\n          case \"GroupBackReference\": // assertions do not affect potential starting codes\n\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n\n        var atom = term;\n\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n\n            forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code; // cannot optimize when ignoreCase is\n\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  } // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n\n\n                  if (range.to >= minOptimizationVal) {\n                    var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        } // reached a mandatory production, no more **start** codes can be found on this alternative\n\n\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n\n        if ( // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n\n      break;\n\n    /* istanbul ignore next */\n\n    default:\n      throw Error(\"non exhaustive match!\");\n  } // console.log(Object.keys(result).length)\n\n\n  return values(result);\n}\n\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n\n  if (upperChar !== char) {\n    var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n\n    if (lowerChar !== char) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\n\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n\n  if (!ast.value) {\n    return false;\n  }\n\n  return isArray(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\n\nvar CharCodeFinder =\n/** @class */\nfunction (_super) {\n  __extends(CharCodeFinder, _super);\n\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    } // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n\n\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n\n    _super.prototype.visitChildren.call(this, node);\n  };\n\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n\n  return CharCodeFinder;\n}(BaseRegExpVisitor);\n\nexport function canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find(pattern, function (char) {\n      return contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}","map":{"version":3,"mappings":"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","names":["VERSION","BaseRegExpVisitor","forEach","contains","PRINT_ERROR","PRINT_WARNING","find","isArray","every","values","getRegExpAst","charCodeToOptimizedIndex","minOptimizationVal","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","toString","msgSuffix","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","code","range","rangeCode","from","to","minUnOptVal","maxUnOptVal","minOptIdx","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","__extends","_super","_this","CharCodeFinder","node","found","visitLookahead","visitNegativeLookahead","visitChildren","call","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sourceRoot":"","sources":["../../../src/scan/reg_exp.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}