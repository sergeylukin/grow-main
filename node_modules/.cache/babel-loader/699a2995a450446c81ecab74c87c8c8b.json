{"ast":null,"code":"/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\n\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}","map":{"version":3,"mappings":"AAEA;;;;;;;AAOA,OAAM,SAAUA,yBAAV,CACJC,gBADI,EAEJC,eAFI,EAEmB;AAEvB;AACA,MAAIC,KAAK,CAACF,gBAAgB,CAACG,WAAlB,CAAL,KAAwC,IAA5C,EAAkD;AAChD;AACA;AACA;AACAH,oBAAgB,CAACG,WAAjB,GAA+BF,eAAe,CAACE,WAA/C;AACAH,oBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;AACD,GAND,CAOA;AACA;AACA;AACA;AAVA,OAWK,IAAIJ,gBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C,KAA2D,IAA/D,EAAqE;AACxEJ,oBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;AACD;AACF;AAED;;;;;;;;AAOA,OAAM,SAAUC,mBAAV,CACJL,gBADI,EAEJC,eAFI,EAE4B;AAEhC;AACA,MAAIC,KAAK,CAACF,gBAAgB,CAACG,WAAlB,CAAL,KAAwC,IAA5C,EAAkD;AAChD;AACA;AACA;AACAH,oBAAgB,CAACG,WAAjB,GAA+BF,eAAe,CAACE,WAA/C;AACAH,oBAAgB,CAACM,WAAjB,GAA+BL,eAAe,CAACK,WAA/C;AACAN,oBAAgB,CAACO,SAAjB,GAA6BN,eAAe,CAACM,SAA7C;AACAP,oBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;AACAJ,oBAAgB,CAACQ,SAAjB,GAA6BP,eAAe,CAACO,SAA7C;AACAR,oBAAgB,CAACS,OAAjB,GAA2BR,eAAe,CAACQ,OAA3C;AACD,GAVD,CAWA;AACA;AACA;AACA;AAdA,OAeK,IAAIT,gBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C,KAA2D,IAA/D,EAAqE;AACxEJ,oBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;AACAJ,oBAAgB,CAACQ,SAAjB,GAA6BP,eAAe,CAACO,SAA7C;AACAR,oBAAgB,CAACS,OAAjB,GAA2BR,eAAe,CAACQ,OAA3C;AACD;AACF;AAED,OAAM,SAAUC,gBAAV,CACJC,IADI,EAEJC,KAFI,EAGJC,aAHI,EAGiB;AAErB,MAAIF,IAAI,CAACG,QAAL,CAAcD,aAAd,MAAiCE,SAArC,EAAgD;AAC9CJ,QAAI,CAACG,QAAL,CAAcD,aAAd,IAA+B,CAACD,KAAD,CAA/B;AACD,GAFD,MAEO;AACLD,QAAI,CAACG,QAAL,CAAcD,aAAd,EAA6BG,IAA7B,CAAkCJ,KAAlC;AACD;AACF;AAED,OAAM,SAAUK,oBAAV,CACJN,IADI,EAEJO,QAFI,EAGJC,UAHI,EAGW;AAEf,MAAIR,IAAI,CAACG,QAAL,CAAcI,QAAd,MAA4BH,SAAhC,EAA2C;AACzCJ,QAAI,CAACG,QAAL,CAAcI,QAAd,IAA0B,CAACC,UAAD,CAA1B;AACD,GAFD,MAEO;AACLR,QAAI,CAACG,QAAL,CAAcI,QAAd,EAAwBF,IAAxB,CAA6BG,UAA7B;AACD;AACF","names":["setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","startOffset","endOffset","setNodeLocationFull","startColumn","startLine","endColumn","endLine","addTerminalToCst","node","token","tokenTypeName","children","undefined","push","addNoneTerminalToCst","ruleName","ruleResult"],"sourceRoot":"","sources":["../../../../src/parse/cst/cst.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}