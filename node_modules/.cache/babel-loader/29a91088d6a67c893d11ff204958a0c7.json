{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { Lexer, LexerDefinitionErrorType } from \"./lexer_public\";\nimport { compact, contains, defaults, difference, filter, find, first, flatten, forEach, has, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, mapValues, packArray, PRINT_ERROR, reduce, reject } from \"../utils/utils\";\nimport { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices } from \"./reg_exp\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nvar PATTERN = \"PATTERN\";\nexport var DEFAULT_MODE = \"defaultMode\";\nexport var MODES = \"modes\";\nexport var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nexport function disableSticky() {\n  SUPPORT_STICKY = false;\n}\nexport function enableSticky() {\n  SUPPORT_STICKY = true;\n}\nexport function analyzeTokenTypes(tokenTypes, options) {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: function tracer(msg, action) {\n      return action();\n    }\n  });\n  var tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n    initCharCodeToOptimizedIndexMap();\n  });\n  var onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", function () {\n    onlyRelevantTypes = reject(tokenTypes, function (currType) {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  var hasCustom = false;\n  var allTransformedPatterns;\n  tracer(\"Transform Patterns\", function () {\n    hasCustom = false;\n    allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n      var currPattern = currType[PATTERN];\n      /* istanbul ignore else */\n\n      if (isRegExp(currPattern)) {\n        var regExpSource = currPattern.source;\n\n        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n        !contains([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n          // escaped meta Characters: /\\+/ /\\[/\n          // or redundant escaping: /\\a/\n          // without the escaping \"\\\"\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction(currPattern)) {\n        hasCustom = true; // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n\n        return {\n          exec: currPattern\n        };\n      } else if (has(currPattern, \"exec\")) {\n        hasCustom = true; // ICustomPattern\n\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          var wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  var patternIdxToType;\n  var patternIdxToGroup;\n  var patternIdxToLongerAltIdx;\n  var patternIdxToPushMode;\n  var patternIdxToPopMode;\n  tracer(\"misc mapping\", function () {\n    patternIdxToType = map(onlyRelevantTypes, function (currType) {\n      return currType.tokenTypeIdx;\n    });\n    patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n      var groupName = clazz.GROUP;\n      /* istanbul ignore next */\n\n      if (groupName === Lexer.SKIPPED) {\n        return undefined;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdx = map(onlyRelevantTypes, function (clazz) {\n      var longerAltType = clazz.LONGER_ALT;\n\n      if (longerAltType) {\n        var longerAltIdx = indexOf(onlyRelevantTypes, longerAltType);\n        return longerAltIdx;\n      }\n    });\n    patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) {\n      return clazz.PUSH_MODE;\n    });\n    patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n      return has(clazz, \"POP_MODE\");\n    });\n  });\n  var patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", function () {\n    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n      return false;\n    });\n\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return tokType.LINE_BREAKS;\n        } else {\n          if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n            return canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          }\n        }\n      });\n    }\n  });\n  var patternIdxToIsCustom;\n  var patternIdxToShort;\n  var emptyGroups;\n  var patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", function () {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n      var groupName = clazz.GROUP;\n\n      if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n\n      return acc;\n    }, {});\n    patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdx[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  var canBeOptimized = true;\n  var charCodeToPatternIdxToConfig = [];\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", function () {\n      charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n        if (typeof currTokType.PATTERN === \"string\") {\n          var charCode = currTokType.PATTERN.charCodeAt(0);\n          var optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray(currTokType.START_CHARS_HINT)) {\n          var lastOptimizedIdx_1;\n          forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n            var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            var currOptimizedIdx = charCodeToOptimizedIndex(charCode); // Avoid adding the config multiple times\n\n            /* istanbul ignore else */\n            // - Difficult to check this scenario effects as it is only a performance\n            //   optimization that does not change correctness\n\n            if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n              lastOptimizedIdx_1 = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") + \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n            }\n          } else {\n            var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            /* istanbul ignore if */\n            // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n            // the first should be a different validation and the second cannot be tested.\n\n            if (isEmpty(optimizedCodes)) {\n              // we cannot understand what codes may start possible matches\n              // The optimization correctness requires knowing start codes for ALL patterns.\n              // Not actually sure this is an error, no debug message\n              canBeOptimized = false;\n            }\n\n            forEach(optimizedCodes, function (code) {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(\"\" + failedOptimizationPrefixMsg + (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n          }\n\n          canBeOptimized = false;\n        }\n\n        return result;\n      }, []);\n    });\n  }\n\n  tracer(\"ArrayPacking\", function () {\n    charCodeToPatternIdxToConfig = packArray(charCodeToPatternIdxToConfig);\n  });\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  };\n}\nexport function validatePatterns(tokenTypes, validModesNames) {\n  var errors = [];\n  var missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  var invalidResult = findInvalidPatterns(missingResult.valid);\n  var validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\n\nfunction validateRegExpPattern(tokenTypes) {\n  var errors = [];\n  var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n    return isRegExp(currTokType[PATTERN]);\n  });\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\n\nexport function findMissingPatterns(tokenTypes) {\n  var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n    return !has(currType, PATTERN);\n  });\n  var errors = map(tokenTypesWithMissingPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nexport function findInvalidPatterns(tokenTypes) {\n  var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return !isRegExp(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n  });\n  var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a\" + \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  var valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return {\n    errors: errors,\n    valid: valid\n  };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nexport function findEndOfInputAnchor(tokenTypes) {\n  var EndAnchorFinder =\n  /** @class */\n  function (_super) {\n    __extends(EndAnchorFinder, _super);\n\n    function EndAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.found = false;\n      return _this;\n    }\n\n    EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n      this.found = true;\n    };\n\n    return EndAnchorFinder;\n  }(BaseRegExpVisitor);\n\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" + \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findEmptyMatchRegExps(tokenTypes) {\n  var matchesEmptyString = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern.test(\"\");\n  });\n  var errors = map(matchesEmptyString, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nexport function findStartOfInputAnchor(tokenTypes) {\n  var StartAnchorFinder =\n  /** @class */\n  function (_super) {\n    __extends(StartAnchorFinder, _super);\n\n    function StartAnchorFinder() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.found = false;\n      return _this;\n    }\n\n    StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n      this.found = true;\n    };\n\n    return StartAnchorFinder;\n  }(BaseRegExpVisitor);\n\n  var invalidRegex = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n\n    try {\n      var regexpAst = getRegExpAst(pattern);\n      var startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n  var errors = map(invalidRegex, function (currType) {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\" + \"\\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findUnsupportedFlags(tokenTypes) {\n  var invalidFlags = filter(tokenTypes, function (currType) {\n    var pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  var errors = map(invalidFlags, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n} // This can only test for identical duplicate RegExps, not semantically equivalent ones.\n\nexport function findDuplicatePatterns(tokenTypes) {\n  var found = [];\n  var identicalPatterns = map(tokenTypes, function (outerType) {\n    return reduce(tokenTypes, function (result, innerType) {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !contains(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n        // in essence we are creating Equivalence classes on equality relation.\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact(identicalPatterns);\n  var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n    return currIdenticalSet.length > 1;\n  });\n  var errors = map(duplicatePatterns, function (setOfIdentical) {\n    var tokenTypeNames = map(setOfIdentical, function (currType) {\n      return currType.name;\n    });\n    var dupPatternSrc = first(setOfIdentical).PATTERN;\n    return {\n      message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" + (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nexport function findInvalidGroupType(tokenTypes) {\n  var invalidTypes = filter(tokenTypes, function (clazz) {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n\n    var group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n  var errors = map(invalidTypes, function (currType) {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nexport function findModesThatDoNotExist(tokenTypes, validModes) {\n  var invalidModes = filter(tokenTypes, function (clazz) {\n    return clazz.PUSH_MODE !== undefined && !contains(validModes, clazz.PUSH_MODE);\n  });\n  var errors = map(invalidModes, function (tokType) {\n    var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" + \"which does not exist\";\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nexport function findUnreachablePatterns(tokenTypes) {\n  var errors = [];\n  var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n    var pattern = tokType.PATTERN;\n\n    if (pattern === Lexer.NA) {\n      return result;\n    } // a more comprehensive validation for all forms of regExps would require\n    // deeper regExp analysis capabilities\n\n\n    if (isString(pattern)) {\n      result.push({\n        str: pattern,\n        idx: idx,\n        tokenType: tokType\n      });\n    } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n      result.push({\n        str: pattern.source,\n        idx: idx,\n        tokenType: tokType\n      });\n    }\n\n    return result;\n  }, []);\n  forEach(tokenTypes, function (tokType, testIdx) {\n    forEach(canBeTested, function (_a) {\n      var str = _a.str,\n          idx = _a.idx,\n          tokenType = _a.tokenType;\n\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" + (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") + \"in the lexer's definition.\\n\" + \"See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nfunction testTokenType(str, pattern) {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    var regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction noMetaChar(regExp) {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n  return find(metaChars, function (char) {\n    return regExp.source.indexOf(char) !== -1;\n  }) === undefined;\n}\n\nexport function addStartOfInput(pattern) {\n  var flags = pattern.ignoreCase ? \"i\" : \"\"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n\n  return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nexport function addStickyFlag(pattern) {\n  var flags = pattern.ignoreCase ? \"iy\" : \"y\"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n\n  return new RegExp(\"\" + pattern.source, flags);\n}\nexport function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var errors = []; // some run time checks to help the end users.\n\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n\n  if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" + \"which does not exist\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n      forEach(currModeValue, function (currTokType, currIdx) {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" + (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        }\n      });\n    });\n  }\n\n  return errors;\n}\nexport function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  var warnings = [];\n  var hasAnyLineBreak = false;\n  var allTokenTypes = compact(flatten(mapValues(lexerDefinition.modes, function (tokTypes) {\n    return tokTypes;\n  })));\n  var concreteTokenTypes = reject(allTokenTypes, function (currType) {\n    return currType[PATTERN] === Lexer.NA;\n  });\n  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n\n  if (trackLines) {\n    forEach(concreteTokenTypes, function (tokType) {\n      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n\n      if (currIssue !== false) {\n        var message = buildLineBreakIssueMessage(tokType, currIssue);\n        var warningDescriptor = {\n          message: message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\" + \"\\tThis Lexer has been defined to track line and column information,\\n\" + \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" + \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" + \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n\n  return warnings;\n}\nexport function cloneEmptyGroups(emptyGroups) {\n  var clonedResult = {};\n  var groupKeys = keys(emptyGroups);\n  forEach(groupKeys, function (currKey) {\n    var currGroupValue = emptyGroups[currKey];\n    /* istanbul ignore else */\n\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n} // TODO: refactor to avoid duplication\n\nexport function isCustomPattern(tokenType) {\n  var pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function isShortPattern(pattern) {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\n\nexport var LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function test(text) {\n    var len = text.length;\n\n    for (var i = this.lastIndex; i < len; i++) {\n      var c = text.charCodeAt(i);\n\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n  lastIndex: 0\n};\n\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return {\n        issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(tokType, details) {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return \"Warning: unable to identify line terminator usage in pattern.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + (\"\\t Root cause: \" + details.errMsg + \".\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" + (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction getCharCodes(charsOrCodes) {\n  var charCodes = map(charsOrCodes, function (numOrString) {\n    if (isString(numOrString) && numOrString.length > 0) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\n\nfunction addToMapOfArrays(map, key, value) {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\n\nexport var minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\n\nexport function charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\n\nvar charCodeToOptimizedIdxMap = [];\n\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n\n    for (var i = 0; i < 65536; i++) {\n      /* tslint:disable */\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n      /* tslint:enable */\n    }\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,iBAAT,QAAkC,eAAlC;AACA,SAAsBC,KAAtB,EAA6BC,wBAA7B,QAA6D,gBAA7D;AACA,SACEC,OADF,EAEEC,QAFF,EAGEC,QAHF,EAIEC,UAJF,EAKEC,MALF,EAMEC,IANF,EAOEC,KAPF,EAQEC,OARF,EASEC,OATF,EAUEC,GAVF,EAWEC,OAXF,EAYEC,OAZF,EAaEC,OAbF,EAcEC,UAdF,EAeEC,QAfF,EAgBEC,QAhBF,EAiBEC,WAjBF,EAkBEC,IAlBF,EAmBEC,GAnBF,EAoBEC,SApBF,EAqBEC,SArBF,EAsBEC,WAtBF,EAuBEC,MAvBF,EAwBEC,MAxBF,QAyBO,gBAzBP;AA0BA,SACEC,gBADF,EAEEC,2BAFF,EAGEC,6BAHF,QAIO,WAJP;AAYA,SAASC,YAAT,QAA6B,kBAA7B;AAEA,IAAMC,OAAO,GAAG,SAAhB;AACA,OAAO,IAAMC,YAAY,GAAG,aAArB;AACP,OAAO,IAAMC,KAAK,GAAG,OAAd;AAsBP,OAAO,IAAIC,cAAc,GACvB,OAAa,IAAIC,MAAJ,CAAW,MAAX,EAAoBC,MAAjC,KAA4C,SADvC;AAGP,OAAM,SAAUC,aAAV,GAAuB;AAC3BH,gBAAc,GAAG,KAAjB;AACD;AAED,OAAM,SAAUI,YAAV,GAAsB;AAC1BJ,gBAAc,GAAG,IAAjB;AACD;AAED,OAAM,SAAUK,iBAAV,CACJC,UADI,EAEJC,OAFI,EAUH;AAEDA,SAAO,GAAGpC,QAAQ,CAACoC,OAAD,EAAU;AAC1BC,aAAS,EAAER,cADe;AAE1BS,SAAK,EAAE,KAFmB;AAG1BC,YAAQ,EAAE,KAHgB;AAI1BC,oBAAgB,EAAE,MAJQ;AAK1BC,4BAAwB,EAAE,CAAC,IAAD,EAAO,IAAP,CALA;AAM1BC,UAAM,EAAE,gBAACC,GAAD,EAAMC,MAAN,EAAY;AAAK,mBAAM,EAAN;AAAQ;AANP,GAAV,CAAlB;AASA,MAAMF,MAAM,GAAGN,OAAO,CAACM,MAAvB;AAEAA,QAAM,CAAC,iCAAD,EAAoC;AACxCG,mCAA+B;AAChC,GAFK,CAAN;AAIA,MAAIC,iBAAJ;AACAJ,QAAM,CAAC,iBAAD,EAAoB;AACxBI,qBAAiB,GAAGzB,MAAM,CAACc,UAAD,EAAa,UAACY,QAAD,EAAS;AAC9C,aAAOA,QAAQ,CAACrB,OAAD,CAAR,KAAsB9B,KAAK,CAACoD,EAAnC;AACD,KAFyB,CAA1B;AAGD,GAJK,CAAN;AAMA,MAAIC,SAAS,GAAG,KAAhB;AACA,MAAIC,sBAAJ;AACAR,QAAM,CAAC,oBAAD,EAAuB;AAC3BO,aAAS,GAAG,KAAZ;AACAC,0BAAsB,GAAGlC,GAAG,CAAC8B,iBAAD,EAAoB,UAACC,QAAD,EAAS;AACvD,UAAII,WAAW,GAAGJ,QAAQ,CAACrB,OAAD,CAA1B;AAEA;;AACA,UAAId,QAAQ,CAACuC,WAAD,CAAZ,EAA2B;AACzB,YAAIC,YAAY,GAAGD,WAAW,CAACE,MAA/B;;AACA,YACED,YAAY,CAACE,MAAb,KAAwB,CAAxB,IACA;AACAF,oBAAY,KAAK,GAFjB,IAGAA,YAAY,KAAK,GAHjB,IAIAA,YAAY,KAAK,GAJjB,IAKA,CAACD,WAAW,CAACI,UANf,EAOE;AACA,iBAAOH,YAAP;AACD,SATD,MASO,IACLA,YAAY,CAACE,MAAb,KAAwB,CAAxB,IACAF,YAAY,CAAC,CAAD,CAAZ,KAAoB,IADpB,IAEA;AACA,SAACrD,QAAQ,CACP,CACE,GADF,EAEE,GAFF,EAGE,GAHF,EAIE,GAJF,EAKE,GALF,EAME,GANF,EAOE,GAPF,EAQE,GARF,EASE,GATF,EAUE,GAVF,EAWE,GAXF,EAYE,GAZF,EAaE,GAbF,EAcE,GAdF,EAeE,GAfF,EAgBE,GAhBF,CADO,EAmBPqD,YAAY,CAAC,CAAD,CAnBL,CAJJ,EAyBL;AACA;AACA;AACA;AACA,iBAAOA,YAAY,CAAC,CAAD,CAAnB;AACD,SA9BM,MA8BA;AACL,iBAAOhB,OAAO,CAACC,SAAR,GACHmB,aAAa,CAACL,WAAD,CADV,GAEHM,eAAe,CAACN,WAAD,CAFnB;AAGD;AACF,OA9CD,MA8CO,IAAIxC,UAAU,CAACwC,WAAD,CAAd,EAA6B;AAClCF,iBAAS,GAAG,IAAZ,CADkC,CAElC;;AACA,eAAO;AAAES,cAAI,EAAEP;AAAR,SAAP;AACD,OAJM,MAIA,IAAI5C,GAAG,CAAC4C,WAAD,EAAc,MAAd,CAAP,EAA8B;AACnCF,iBAAS,GAAG,IAAZ,CADmC,CAEnC;;AACA,eAAOE,WAAP;AACD,OAJM,MAIA,IAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;AAC1C,YAAIA,WAAW,CAACG,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,iBAAOH,WAAP;AACD,SAFD,MAEO;AACL,cAAIQ,mBAAmB,GAAGR,WAAW,CAACS,OAAZ,CACxB,qBADwB,EAExB,MAFwB,CAA1B;AAIA,cAAIC,aAAa,GAAG,IAAI/B,MAAJ,CAAW6B,mBAAX,CAApB;AACA,iBAAOvB,OAAO,CAACC,SAAR,GACHmB,aAAa,CAACK,aAAD,CADV,GAEHJ,eAAe,CAACI,aAAD,CAFnB;AAGD;AACF,OAbM,MAaA;AACL,cAAMC,KAAK,CAAC,sBAAD,CAAX;AACD;AACF,KA1E2B,CAA5B;AA2ED,GA7EK,CAAN;AA+EA,MAAIC,gBAAJ;AACA,MAAIC,iBAAJ;AACA,MAAIC,wBAAJ;AACA,MAAIC,oBAAJ;AACA,MAAIC,mBAAJ;AACAzB,QAAM,CAAC,cAAD,EAAiB;AACrBqB,oBAAgB,GAAG/C,GAAG,CACpB8B,iBADoB,EAEpB,UAACC,QAAD,EAAS;AAAK,qBAAQ,CAACqB,YAAT;AAAqB,KAFf,CAAtB;AAKAJ,qBAAiB,GAAGhD,GAAG,CAAC8B,iBAAD,EAAoB,UAACuB,KAAD,EAAW;AACpD,UAAIC,SAAS,GAAGD,KAAK,CAACE,KAAtB;AACA;;AACA,UAAID,SAAS,KAAK1E,KAAK,CAAC4E,OAAxB,EAAiC;AAC/B,eAAOC,SAAP;AACD,OAFD,MAEO,IAAI5D,QAAQ,CAACyD,SAAD,CAAZ,EAAyB;AAC9B,eAAOA,SAAP;AACD,OAFM,MAEA,IAAIxD,WAAW,CAACwD,SAAD,CAAf,EAA4B;AACjC,eAAO,KAAP;AACD,OAFM,MAEA;AACL,cAAMR,KAAK,CAAC,sBAAD,CAAX;AACD;AACF,KAZsB,CAAvB;AAcAG,4BAAwB,GAAGjD,GAAG,CAAC8B,iBAAD,EAAoB,UAACuB,KAAD,EAAW;AAC3D,UAAIK,aAAa,GAAGL,KAAK,CAACM,UAA1B;;AAEA,UAAID,aAAJ,EAAmB;AACjB,YAAIE,YAAY,GAAGpE,OAAO,CAACsC,iBAAD,EAAoB4B,aAApB,CAA1B;AACA,eAAOE,YAAP;AACD;AACF,KAP6B,CAA9B;AASAV,wBAAoB,GAAGlD,GAAG,CACxB8B,iBADwB,EAExB,UAACuB,KAAD,EAAW;AAAK,kBAAK,CAACQ,SAAN;AAAe,KAFP,CAA1B;AAKAV,uBAAmB,GAAGnD,GAAG,CAAC8B,iBAAD,EAAoB,UAACuB,KAAD,EAAW;AACtD,gBAAG,CAACA,KAAD,EAAQ,UAAR,CAAH;AAAsB,KADC,CAAzB;AAGD,GArCK,CAAN;AAuCA,MAAIS,6BAAJ;AACApC,QAAM,CAAC,0BAAD,EAA6B;AACjC,QAAMqC,uBAAuB,GAAGC,YAAY,CAC1C5C,OAAO,CAACK,wBADkC,CAA5C;AAGAqC,iCAA6B,GAAG9D,GAAG,CAAC8B,iBAAD,EAAoB,UAACmC,OAAD,EAAQ;AAAK;AAAK,KAAtC,CAAnC;;AACA,QAAI7C,OAAO,CAACI,gBAAR,KAA6B,YAAjC,EAA+C;AAC7CsC,mCAA6B,GAAG9D,GAAG,CAAC8B,iBAAD,EAAoB,UAACmC,OAAD,EAAQ;AAC7D,YAAI1E,GAAG,CAAC0E,OAAD,EAAU,aAAV,CAAP,EAAiC;AAC/B,iBAAOA,OAAO,CAACC,WAAf;AACD,SAFD,MAEO;AACL,cACEC,qBAAqB,CAACF,OAAD,EAAUF,uBAAV,CAArB,KAA4D,KAD9D,EAEE;AACA,mBAAOzD,gBAAgB,CAACyD,uBAAD,EAA0BE,OAAO,CAACvD,OAAlC,CAAvB;AACD;AACF;AACF,OAVkC,CAAnC;AAWD;AACF,GAlBK,CAAN;AAoBA,MAAI0D,oBAAJ;AACA,MAAIC,iBAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,kBAAJ;AACA7C,QAAM,CAAC,iBAAD,EAAoB;AACxB0C,wBAAoB,GAAGpE,GAAG,CAAC8B,iBAAD,EAAoB0C,eAApB,CAA1B;AACAH,qBAAiB,GAAGrE,GAAG,CAACkC,sBAAD,EAAyBuC,cAAzB,CAAvB;AAEAH,eAAW,GAAGlE,MAAM,CAClB0B,iBADkB,EAElB,UAAC4C,GAAD,EAAMrB,KAAN,EAAgB;AACd,UAAIC,SAAS,GAAGD,KAAK,CAACE,KAAtB;;AACA,UAAI1D,QAAQ,CAACyD,SAAD,CAAR,IAAuB,EAAEA,SAAS,KAAK1E,KAAK,CAAC4E,OAAtB,CAA3B,EAA2D;AACzDkB,WAAG,CAACpB,SAAD,CAAH,GAAiB,EAAjB;AACD;;AACD,aAAOoB,GAAP;AACD,KARiB,EASlB,EATkB,CAApB;AAYAH,sBAAkB,GAAGvE,GAAG,CAACkC,sBAAD,EAAyB,UAACyC,CAAD,EAAIC,GAAJ,EAAO;AACtD,aAAO;AACLC,eAAO,EAAE3C,sBAAsB,CAAC0C,GAAD,CAD1B;AAELE,iBAAS,EAAE7B,wBAAwB,CAAC2B,GAAD,CAF9B;AAGLG,yBAAiB,EAAEjB,6BAA6B,CAACc,GAAD,CAH3C;AAILI,gBAAQ,EAAEZ,oBAAoB,CAACQ,GAAD,CAJzB;AAKLK,aAAK,EAAEZ,iBAAiB,CAACO,GAAD,CALnB;AAMLM,aAAK,EAAElC,iBAAiB,CAAC4B,GAAD,CANnB;AAOLO,YAAI,EAAEjC,oBAAoB,CAAC0B,GAAD,CAPrB;AAQLQ,WAAG,EAAEjC,mBAAmB,CAACyB,GAAD,CARnB;AASLxB,oBAAY,EAAEL,gBAAgB,CAAC6B,GAAD,CATzB;AAULS,iBAAS,EAAEvD,iBAAiB,CAAC8C,GAAD;AAVvB,OAAP;AAYD,KAbuB,CAAxB;AAcD,GA9BK,CAAN;AAgCA,MAAIU,cAAc,GAAG,IAArB;AACA,MAAIC,4BAA4B,GAAG,EAAnC;;AAEA,MAAI,CAACnE,OAAO,CAACG,QAAb,EAAuB;AACrBG,UAAM,CAAC,yBAAD,EAA4B;AAChC6D,kCAA4B,GAAGnF,MAAM,CACnC0B,iBADmC,EAEnC,UAAC0D,MAAD,EAASC,WAAT,EAAsBb,GAAtB,EAAyB;AACvB,YAAI,OAAOa,WAAW,CAAC/E,OAAnB,KAA+B,QAAnC,EAA6C;AAC3C,cAAMgF,QAAQ,GAAGD,WAAW,CAAC/E,OAAZ,CAAoBiF,UAApB,CAA+B,CAA/B,CAAjB;AACA,cAAMC,YAAY,GAAGC,wBAAwB,CAACH,QAAD,CAA7C;AACAI,0BAAgB,CAACN,MAAD,EAASI,YAAT,EAAuBrB,kBAAkB,CAACK,GAAD,CAAzC,CAAhB;AACD,SAJD,MAIO,IAAInF,OAAO,CAACgG,WAAW,CAACM,gBAAb,CAAX,EAA2C;AAChD,cAAIC,kBAAJ;AACA1G,iBAAO,CAACmG,WAAW,CAACM,gBAAb,EAA+B,UAACE,SAAD,EAAU;AAC9C,gBAAMP,QAAQ,GACZ,OAAOO,SAAP,KAAqB,QAArB,GACIA,SAAS,CAACN,UAAV,CAAqB,CAArB,CADJ,GAEIM,SAHN;AAIA,gBAAMC,gBAAgB,GAAGL,wBAAwB,CAACH,QAAD,CAAjD,CAL8C,CAM9C;;AACA;AACA;AACA;;AACA,gBAAIM,kBAAgB,KAAKE,gBAAzB,EAA2C;AACzCF,gCAAgB,GAAGE,gBAAnB;AACAJ,8BAAgB,CACdN,MADc,EAEdU,gBAFc,EAGd3B,kBAAkB,CAACK,GAAD,CAHJ,CAAhB;AAKD;AACF,WAlBM,CAAP;AAmBD,SArBM,MAqBA,IAAIhF,QAAQ,CAAC6F,WAAW,CAAC/E,OAAb,CAAZ,EAAmC;AACxC,cAAI+E,WAAW,CAAC/E,OAAZ,CAAoByF,OAAxB,EAAiC;AAC/Bb,0BAAc,GAAG,KAAjB;;AACA,gBAAIlE,OAAO,CAACgF,mBAAZ,EAAiC;AAC/BjG,yBAAW,CACT,KAAGI,2BAAH,IACE,2BAAyBkF,WAAW,CAAC/E,OAAZ,CAAoB2F,QAApB,EAAzB,GAAuD,eADzD,IAEE,sFAFF,GAGE,6DAHF,GAIE,kGALO,CAAX;AAOD;AACF,WAXD,MAWO;AACL,gBAAIC,cAAc,GAAG9F,6BAA6B,CAChDiF,WAAW,CAAC/E,OADoC,EAEhDU,OAAO,CAACgF,mBAFwC,CAAlD;AAIA;AACA;AACA;;AACA,gBAAI1G,OAAO,CAAC4G,cAAD,CAAX,EAA6B;AAC3B;AACA;AACA;AACAhB,4BAAc,GAAG,KAAjB;AACD;;AACDhG,mBAAO,CAACgH,cAAD,EAAiB,UAACC,IAAD,EAAK;AAC3BT,8BAAgB,CAACN,MAAD,EAASe,IAAT,EAAehC,kBAAkB,CAACK,GAAD,CAAjC,CAAhB;AACD,aAFM,CAAP;AAGD;AACF,SA9BM,MA8BA;AACL,cAAIxD,OAAO,CAACgF,mBAAZ,EAAiC;AAC/BjG,uBAAW,CACT,KAAGI,2BAAH,IACE,mBAAiBkF,WAAW,CAACe,IAA7B,GAAiC,qFADnC,IAEE,6DAFF,GAGE,iGAJO,CAAX;AAMD;;AACDlB,wBAAc,GAAG,KAAjB;AACD;;AAED,eAAOE,MAAP;AACD,OAvEkC,EAwEnC,EAxEmC,CAArC;AA0ED,KA3EK,CAAN;AA4ED;;AACD9D,QAAM,CAAC,cAAD,EAAiB;AACrB6D,gCAA4B,GAAGrF,SAAS,CAACqF,4BAAD,CAAxC;AACD,GAFK,CAAN;AAIA,SAAO;AACLjB,eAAW,EAAEA,WADR;AAELC,sBAAkB,EAAEA,kBAFf;AAGLgB,gCAA4B,EAAEA,4BAHzB;AAILtD,aAAS,EAAEA,SAJN;AAKLqD,kBAAc,EAAEA;AALX,GAAP;AAOD;AAED,OAAM,SAAUmB,gBAAV,CACJtF,UADI,EAEJuF,eAFI,EAEqB;AAEzB,MAAIC,MAAM,GAAG,EAAb;AAEA,MAAIC,aAAa,GAAGC,mBAAmB,CAAC1F,UAAD,CAAvC;AACAwF,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcF,aAAa,CAACD,MAA5B,CAAT;AAEA,MAAII,aAAa,GAAGC,mBAAmB,CAACJ,aAAa,CAACK,KAAf,CAAvC;AACA,MAAIC,eAAe,GAAGH,aAAa,CAACE,KAApC;AACAN,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcC,aAAa,CAACJ,MAA5B,CAAT;AAEAA,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcK,qBAAqB,CAACD,eAAD,CAAnC,CAAT;AAEAP,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcM,oBAAoB,CAACF,eAAD,CAAlC,CAAT;AAEAP,QAAM,GAAGA,MAAM,CAACG,MAAP,CACPO,uBAAuB,CAACH,eAAD,EAAkBR,eAAlB,CADhB,CAAT;AAIAC,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcQ,uBAAuB,CAACJ,eAAD,CAArC,CAAT;AAEA,SAAOP,MAAP;AACD;;AAED,SAASQ,qBAAT,CACEhG,UADF,EACyB;AAEvB,MAAIwF,MAAM,GAAG,EAAb;AACA,MAAIY,kBAAkB,GAAGrI,MAAM,CAACiC,UAAD,EAAa,UAACsE,WAAD,EAAY;AACtD,mBAAQ,CAACA,WAAW,CAAC/E,OAAD,CAAZ,CAAR;AAA8B,GADD,CAA/B;AAIAiG,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcU,oBAAoB,CAACD,kBAAD,CAAlC,CAAT;AAEAZ,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcW,sBAAsB,CAACF,kBAAD,CAApC,CAAT;AAEAZ,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcY,oBAAoB,CAACH,kBAAD,CAAlC,CAAT;AAEAZ,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAca,qBAAqB,CAACJ,kBAAD,CAAnC,CAAT;AAEAZ,QAAM,GAAGA,MAAM,CAACG,MAAP,CAAcc,qBAAqB,CAACL,kBAAD,CAAnC,CAAT;AAEA,SAAOZ,MAAP;AACD;;AAOD,OAAM,SAAUE,mBAAV,CACJ1F,UADI,EACmB;AAEvB,MAAI0G,4BAA4B,GAAG3I,MAAM,CAACiC,UAAD,EAAa,UAACY,QAAD,EAAS;AAC7D,WAAO,CAACxC,GAAG,CAACwC,QAAD,EAAWrB,OAAX,CAAX;AACD,GAFwC,CAAzC;AAIA,MAAIiG,MAAM,GAAG3G,GAAG,CAAC6H,4BAAD,EAA+B,UAAC9F,QAAD,EAAS;AACtD,WAAO;AACL+F,aAAO,EACL,mBACA/F,QAAQ,CAACyE,IADT,GAEA,sCAJG;AAKLuB,UAAI,EAAElJ,wBAAwB,CAACmJ,eAL1B;AAML7G,gBAAU,EAAE,CAACY,QAAD;AANP,KAAP;AAQD,GATe,CAAhB;AAWA,MAAIkF,KAAK,GAAGhI,UAAU,CAACkC,UAAD,EAAa0G,4BAAb,CAAtB;AACA,SAAO;AAAElB,UAAM,QAAR;AAAUM,SAAK;AAAf,GAAP;AACD;AAED,OAAM,SAAUD,mBAAV,CACJ7F,UADI,EACmB;AAEvB,MAAI8G,4BAA4B,GAAG/I,MAAM,CAACiC,UAAD,EAAa,UAACY,QAAD,EAAS;AAC7D,QAAI8C,OAAO,GAAG9C,QAAQ,CAACrB,OAAD,CAAtB;AACA,WACE,CAACd,QAAQ,CAACiF,OAAD,CAAT,IACA,CAAClF,UAAU,CAACkF,OAAD,CADX,IAEA,CAACtF,GAAG,CAACsF,OAAD,EAAU,MAAV,CAFJ,IAGA,CAAChF,QAAQ,CAACgF,OAAD,CAJX;AAMD,GARwC,CAAzC;AAUA,MAAI8B,MAAM,GAAG3G,GAAG,CAACiI,4BAAD,EAA+B,UAAClG,QAAD,EAAS;AACtD,WAAO;AACL+F,aAAO,EACL,mBACA/F,QAAQ,CAACyE,IADT,GAEA,6CAFA,GAGA,8GALG;AAMLuB,UAAI,EAAElJ,wBAAwB,CAACqJ,eAN1B;AAOL/G,gBAAU,EAAE,CAACY,QAAD;AAPP,KAAP;AASD,GAVe,CAAhB;AAYA,MAAIkF,KAAK,GAAGhI,UAAU,CAACkC,UAAD,EAAa8G,4BAAb,CAAtB;AACA,SAAO;AAAEtB,UAAM,QAAR;AAAUM,SAAK;AAAf,GAAP;AACD;AAED,IAAMkB,YAAY,GAAG,WAArB;AAEA,OAAM,SAAUX,oBAAV,CACJrG,UADI,EACmB;AAEvB;AAAA;AAAA;AAA8BiH;;AAA9B;AAAA;;AACEC,oBAAQ,KAAR;;AAKD;;AAHCC,yDAAeC,IAAf,EAAmB;AACjB,WAAKC,KAAL,GAAa,IAAb;AACD,KAFD;;AAGF;AANA,IAA8B7J,iBAA9B;;AAQA,MAAI8J,YAAY,GAAGvJ,MAAM,CAACiC,UAAD,EAAa,UAACY,QAAD,EAAS;AAC7C,QAAM8C,OAAO,GAAG9C,QAAQ,CAACrB,OAAD,CAAxB;;AAEA,QAAI;AACF,UAAMgI,SAAS,GAAGjI,YAAY,CAACoE,OAAD,CAA9B;AACA,UAAM8D,gBAAgB,GAAG,IAAIL,eAAJ,EAAzB;AACAK,sBAAgB,CAACC,KAAjB,CAAuBF,SAAvB;AAEA,aAAOC,gBAAgB,CAACH,KAAxB;AACD,KAND,CAME,OAAOK,CAAP,EAAU;AACV;;AACA;AACA,aAAOV,YAAY,CAACW,IAAb,CAAkBjE,OAAO,CAACxC,MAA1B,CAAP;AACD;AACF,GAdwB,CAAzB;AAgBA,MAAIsE,MAAM,GAAG3G,GAAG,CAACyI,YAAD,EAAe,UAAC1G,QAAD,EAAS;AACtC,WAAO;AACL+F,aAAO,EACL,sCACA,kBADA,GAEA/F,QAAQ,CAACyE,IAFT,GAGA,8DAHA,GAIA,oEAJA,GAKA,gBAPG;AAQLuB,UAAI,EAAElJ,wBAAwB,CAACkK,gBAR1B;AASL5H,gBAAU,EAAE,CAACY,QAAD;AATP,KAAP;AAWD,GAZe,CAAhB;AAcA,SAAO4E,MAAP;AACD;AAED,OAAM,SAAUiB,qBAAV,CACJzG,UADI,EACmB;AAEvB,MAAI6H,kBAAkB,GAAG9J,MAAM,CAACiC,UAAD,EAAa,UAACY,QAAD,EAAS;AACnD,QAAI8C,OAAO,GAAG9C,QAAQ,CAACrB,OAAD,CAAtB;AACA,WAAOmE,OAAO,CAACiE,IAAR,CAAa,EAAb,CAAP;AACD,GAH8B,CAA/B;AAKA,MAAInC,MAAM,GAAG3G,GAAG,CAACgJ,kBAAD,EAAqB,UAACjH,QAAD,EAAS;AAC5C,WAAO;AACL+F,aAAO,EACL,mBACA/F,QAAQ,CAACyE,IADT,GAEA,oDAJG;AAKLuB,UAAI,EAAElJ,wBAAwB,CAACoK,mBAL1B;AAML9H,gBAAU,EAAE,CAACY,QAAD;AANP,KAAP;AAQD,GATe,CAAhB;AAWA,SAAO4E,MAAP;AACD;AAED,IAAMuC,cAAc,GAAG,gBAAvB;AAEA,OAAM,SAAUzB,sBAAV,CACJtG,UADI,EACmB;AAEvB;AAAA;AAAA;AAAgCiH;;AAAhC;AAAA;;AACEC,oBAAQ,KAAR;;AAKD;;AAHCc,6DAAiBZ,IAAjB,EAAqB;AACnB,WAAKC,KAAL,GAAa,IAAb;AACD,KAFD;;AAGF;AANA,IAAgC7J,iBAAhC;;AAQA,MAAI8J,YAAY,GAAGvJ,MAAM,CAACiC,UAAD,EAAa,UAACY,QAAD,EAAS;AAC7C,QAAM8C,OAAO,GAAG9C,QAAQ,CAACrB,OAAD,CAAxB;;AACA,QAAI;AACF,UAAMgI,SAAS,GAAGjI,YAAY,CAACoE,OAAD,CAA9B;AACA,UAAMuE,kBAAkB,GAAG,IAAID,iBAAJ,EAA3B;AACAC,wBAAkB,CAACR,KAAnB,CAAyBF,SAAzB;AAEA,aAAOU,kBAAkB,CAACZ,KAA1B;AACD,KAND,CAME,OAAOK,CAAP,EAAU;AACV;;AACA;AACA,aAAOK,cAAc,CAACJ,IAAf,CAAoBjE,OAAO,CAACxC,MAA5B,CAAP;AACD;AACF,GAbwB,CAAzB;AAeA,MAAIsE,MAAM,GAAG3G,GAAG,CAACyI,YAAD,EAAe,UAAC1G,QAAD,EAAS;AACtC,WAAO;AACL+F,aAAO,EACL,sCACA,kBADA,GAEA/F,QAAQ,CAACyE,IAFT,GAGA,gEAHA,GAIA,4EAJA,GAKA,gBAPG;AAQLuB,UAAI,EAAElJ,wBAAwB,CAACwK,gBAR1B;AASLlI,gBAAU,EAAE,CAACY,QAAD;AATP,KAAP;AAWD,GAZe,CAAhB;AAcA,SAAO4E,MAAP;AACD;AAED,OAAM,SAAUe,oBAAV,CACJvG,UADI,EACmB;AAEvB,MAAImI,YAAY,GAAGpK,MAAM,CAACiC,UAAD,EAAa,UAACY,QAAD,EAAS;AAC7C,QAAI8C,OAAO,GAAG9C,QAAQ,CAACrB,OAAD,CAAtB;AACA,WAAOmE,OAAO,YAAY/D,MAAnB,KAA8B+D,OAAO,CAAC0E,SAAR,IAAqB1E,OAAO,CAAC2E,MAA3D,CAAP;AACD,GAHwB,CAAzB;AAKA,MAAI7C,MAAM,GAAG3G,GAAG,CAACsJ,YAAD,EAAe,UAACvH,QAAD,EAAS;AACtC,WAAO;AACL+F,aAAO,EACL,mBACA/F,QAAQ,CAACyE,IADT,GAEA,mEAJG;AAKLuB,UAAI,EAAElJ,wBAAwB,CAAC4K,uBAL1B;AAMLtI,gBAAU,EAAE,CAACY,QAAD;AANP,KAAP;AAQD,GATe,CAAhB;AAWA,SAAO4E,MAAP;AACD,C,CAED;;AACA,OAAM,SAAUgB,qBAAV,CACJxG,UADI,EACmB;AAEvB,MAAIqH,KAAK,GAAG,EAAZ;AACA,MAAIkB,iBAAiB,GAAG1J,GAAG,CAACmB,UAAD,EAAa,UAACwI,SAAD,EAAe;AACrD,WAAOvJ,MAAM,CACXe,UADW,EAEX,UAACqE,MAAD,EAASoE,SAAT,EAAuB;AACrB,UACED,SAAS,CAACjJ,OAAV,CAAkB2B,MAAlB,KAA6BuH,SAAS,CAAClJ,OAAV,CAAkB2B,MAA/C,IACA,CAACtD,QAAQ,CAACyJ,KAAD,EAAQoB,SAAR,CADT,IAEAA,SAAS,CAAClJ,OAAV,KAAsB9B,KAAK,CAACoD,EAH9B,EAIE;AACA;AACA;AACAwG,aAAK,CAACrD,IAAN,CAAWyE,SAAX;AACApE,cAAM,CAACL,IAAP,CAAYyE,SAAZ;AACA,eAAOpE,MAAP;AACD;;AACD,aAAOA,MAAP;AACD,KAfU,EAgBX,EAhBW,CAAb;AAkBD,GAnB0B,CAA3B;AAqBAkE,mBAAiB,GAAG5K,OAAO,CAAC4K,iBAAD,CAA3B;AAEA,MAAIG,iBAAiB,GAAG3K,MAAM,CAACwK,iBAAD,EAAoB,UAACI,gBAAD,EAAiB;AACjE,WAAOA,gBAAgB,CAACxH,MAAjB,GAA0B,CAAjC;AACD,GAF6B,CAA9B;AAIA,MAAIqE,MAAM,GAAG3G,GAAG,CAAC6J,iBAAD,EAAoB,UAACE,cAAD,EAAoB;AACtD,QAAIC,cAAc,GAAGhK,GAAG,CAAC+J,cAAD,EAAiB,UAAChI,QAAD,EAAc;AACrD,aAAOA,QAAQ,CAACyE,IAAhB;AACD,KAFuB,CAAxB;AAIA,QAAIyD,aAAa,GAAS7K,KAAK,CAAC2K,cAAD,CAAL,CAAuBrJ,OAAjD;AACA,WAAO;AACLoH,aAAO,EACL,+BAA6BmC,aAA7B,GAA0C,IAA1C,IACA,wDAAsDD,cAAc,CAACE,IAAf,CACpD,IADoD,CAAtD,GAEC,KAHD,CAFG;AAMLnC,UAAI,EAAElJ,wBAAwB,CAACsL,wBAN1B;AAOLhJ,gBAAU,EAAE4I;AAPP,KAAP;AASD,GAfe,CAAhB;AAiBA,SAAOpD,MAAP;AACD;AAED,OAAM,SAAUS,oBAAV,CACJjG,UADI,EACmB;AAEvB,MAAIiJ,YAAY,GAAGlL,MAAM,CAACiC,UAAD,EAAa,UAACkC,KAAD,EAAW;AAC/C,QAAI,CAAC9D,GAAG,CAAC8D,KAAD,EAAQ,OAAR,CAAR,EAA0B;AACxB,aAAO,KAAP;AACD;;AACD,QAAI6B,KAAK,GAAG7B,KAAK,CAACE,KAAlB;AAEA,WAAO2B,KAAK,KAAKtG,KAAK,CAAC4E,OAAhB,IAA2B0B,KAAK,KAAKtG,KAAK,CAACoD,EAA3C,IAAiD,CAACnC,QAAQ,CAACqF,KAAD,CAAjE;AACD,GAPwB,CAAzB;AASA,MAAIyB,MAAM,GAAG3G,GAAG,CAACoK,YAAD,EAAe,UAACrI,QAAD,EAAS;AACtC,WAAO;AACL+F,aAAO,EACL,mBACA/F,QAAQ,CAACyE,IADT,GAEA,+DAJG;AAKLuB,UAAI,EAAElJ,wBAAwB,CAACwL,wBAL1B;AAMLlJ,gBAAU,EAAE,CAACY,QAAD;AANP,KAAP;AAQD,GATe,CAAhB;AAWA,SAAO4E,MAAP;AACD;AAED,OAAM,SAAUU,uBAAV,CACJlG,UADI,EAEJmJ,UAFI,EAEgB;AAEpB,MAAIC,YAAY,GAAGrL,MAAM,CAACiC,UAAD,EAAa,UAACkC,KAAD,EAAW;AAC/C,WACEA,KAAK,CAACQ,SAAN,KAAoBJ,SAApB,IAAiC,CAAC1E,QAAQ,CAACuL,UAAD,EAAajH,KAAK,CAACQ,SAAnB,CAD5C;AAGD,GAJwB,CAAzB;AAMA,MAAI8C,MAAM,GAAG3G,GAAG,CAACuK,YAAD,EAAe,UAACtG,OAAD,EAAQ;AACrC,QAAItC,GAAG,GACL,mBAAiBsC,OAAO,CAACuC,IAAzB,GAA6B,6DAA7B,GAA2FvC,OAAO,CAACJ,SAAnG,GAA4G,IAA5G,GACA,sBAFF;AAGA,WAAO;AACLiE,aAAO,EAAEnG,GADJ;AAELoG,UAAI,EAAElJ,wBAAwB,CAAC2L,wBAF1B;AAGLrJ,gBAAU,EAAE,CAAC8C,OAAD;AAHP,KAAP;AAKD,GATe,CAAhB;AAWA,SAAO0C,MAAP;AACD;AAED,OAAM,SAAUW,uBAAV,CACJnG,UADI,EACmB;AAEvB,MAAMwF,MAAM,GAAG,EAAf;AAEA,MAAM8D,WAAW,GAAGrK,MAAM,CACxBe,UADwB,EAExB,UAACqE,MAAD,EAASvB,OAAT,EAAkBW,GAAlB,EAAqB;AACnB,QAAMC,OAAO,GAAGZ,OAAO,CAACvD,OAAxB;;AAEA,QAAImE,OAAO,KAAKjG,KAAK,CAACoD,EAAtB,EAA0B;AACxB,aAAOwD,MAAP;AACD,KALkB,CAOnB;AACA;;;AACA,QAAI3F,QAAQ,CAACgF,OAAD,CAAZ,EAAuB;AACrBW,YAAM,CAACL,IAAP,CAAY;AAAEuF,WAAG,EAAE7F,OAAP;AAAgBD,WAAG,KAAnB;AAAqBS,iBAAS,EAAEpB;AAAhC,OAAZ;AACD,KAFD,MAEO,IAAIrE,QAAQ,CAACiF,OAAD,CAAR,IAAqB8F,UAAU,CAAC9F,OAAD,CAAnC,EAA8C;AACnDW,YAAM,CAACL,IAAP,CAAY;AAAEuF,WAAG,EAAE7F,OAAO,CAACxC,MAAf;AAAuBuC,WAAG,KAA1B;AAA4BS,iBAAS,EAAEpB;AAAvC,OAAZ;AACD;;AACD,WAAOuB,MAAP;AACD,GAjBuB,EAkBxB,EAlBwB,CAA1B;AAqBAlG,SAAO,CAAC6B,UAAD,EAAa,UAAC8C,OAAD,EAAU2G,OAAV,EAAiB;AACnCtL,WAAO,CAACmL,WAAD,EAAc,UAACI,EAAD,EAAwB;UAArBH,GAAG;UAAE9F,GAAG;UAAES,SAAS;;AACzC,UAAIuF,OAAO,GAAGhG,GAAV,IAAiBkG,aAAa,CAACJ,GAAD,EAAMzG,OAAO,CAACvD,OAAd,CAAlC,EAA0D;AACxD,YAAIiB,GAAG,GACL,cAAY0D,SAAS,CAACmB,IAAtB,GAA0B,4BAA1B,IACA,+CAA6CvC,OAAO,CAACuC,IAArD,GAAyD,IADzD,IAEA,8BAFA,GAGA,8EAJF;AAKAG,cAAM,CAACxB,IAAP,CAAY;AACV2C,iBAAO,EAAEnG,GADC;AAEVoG,cAAI,EAAElJ,wBAAwB,CAACkM,mBAFrB;AAGV5J,oBAAU,EAAE,CAAC8C,OAAD,EAAUoB,SAAV;AAHF,SAAZ;AAKD;AACF,KAbM,CAAP;AAcD,GAfM,CAAP;AAiBA,SAAOsB,MAAP;AACD;;AAED,SAASmE,aAAT,CAAuBJ,GAAvB,EAAoC7F,OAApC,EAAgD;AAC9C;AACA,MAAIjF,QAAQ,CAACiF,OAAD,CAAZ,EAAuB;AACrB,QAAMmG,WAAW,GAAGnG,OAAO,CAACnC,IAAR,CAAagI,GAAb,CAApB;AACA,WAAOM,WAAW,KAAK,IAAhB,IAAwBA,WAAW,CAACC,KAAZ,KAAsB,CAArD;AACD,GAHD,MAGO,IAAItL,UAAU,CAACkF,OAAD,CAAd,EAAyB;AAC9B;AACA,WAAOA,OAAO,CAAC6F,GAAD,EAAM,CAAN,EAAS,EAAT,EAAa,EAAb,CAAd;AACD,GAHM,MAGA,IAAInL,GAAG,CAACsF,OAAD,EAAU,MAAV,CAAP,EAA0B;AAC/B;AACA,WAAOA,OAAO,CAACnC,IAAR,CAAagI,GAAb,EAAkB,CAAlB,EAAqB,EAArB,EAAyB,EAAzB,CAAP;AACD,GAHM,MAGA,IAAI,OAAO7F,OAAP,KAAmB,QAAvB,EAAiC;AACtC,WAAOA,OAAO,KAAK6F,GAAnB;AACD,GAFM,MAEA;AACL,UAAM5H,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;;AAED,SAAS6H,UAAT,CAAoBO,MAApB,EAAkC;AAChC;AACA,MAAMC,SAAS,GAAG,CAChB,GADgB,EAEhB,IAFgB,EAGhB,GAHgB,EAIhB,GAJgB,EAKhB,GALgB,EAMhB,GANgB,EAOhB,GAPgB,EAQhB,GARgB,EAShB,GATgB,EAUhB,GAVgB,EAWhB,GAXgB,EAYhB,GAZgB,EAahB,GAbgB,CAAlB;AAeA,SACEhM,IAAI,CAACgM,SAAD,EAAY,UAACC,IAAD,EAAK;AAAK,iBAAM,CAAC/I,MAAP,CAAc7C,OAAd,CAAsB4L,IAAtB,MAAgC,CAAC,CAAjC;AAAkC,GAAxD,CAAJ,KAAkE3H,SADpE;AAGD;;AAED,OAAM,SAAUhB,eAAV,CAA0BoC,OAA1B,EAAyC;AAC7C,MAAIwG,KAAK,GAAGxG,OAAO,CAACtC,UAAR,GAAqB,GAArB,GAA2B,EAAvC,CAD6C,CAE7C;AACA;;AACA,SAAO,IAAIzB,MAAJ,CAAW,SAAO+D,OAAO,CAACxC,MAAf,GAAqB,GAAhC,EAAqCgJ,KAArC,CAAP;AACD;AAED,OAAM,SAAU7I,aAAV,CAAwBqC,OAAxB,EAAuC;AAC3C,MAAIwG,KAAK,GAAGxG,OAAO,CAACtC,UAAR,GAAqB,IAArB,GAA4B,GAAxC,CAD2C,CAE3C;AACA;;AACA,SAAO,IAAIzB,MAAJ,CAAW,KAAG+D,OAAO,CAACxC,MAAtB,EAAgCgJ,KAAhC,CAAP;AACD;AAED,OAAM,SAAUC,oBAAV,CACJC,eADI,EAEJC,UAFI,EAGJ/J,wBAHI,EAGyC;AAE7C,MAAIkF,MAAM,GAAG,EAAb,CAF6C,CAI7C;;AACA,MAAI,CAACpH,GAAG,CAACgM,eAAD,EAAkB5K,YAAlB,CAAR,EAAyC;AACvCgG,UAAM,CAACxB,IAAP,CAAY;AACV2C,aAAO,EACL,wDACAnH,YADA,GAEA,gCAJQ;AAKVoH,UAAI,EAAElJ,wBAAwB,CAAC4M;AALrB,KAAZ;AAOD;;AACD,MAAI,CAAClM,GAAG,CAACgM,eAAD,EAAkB3K,KAAlB,CAAR,EAAkC;AAChC+F,UAAM,CAACxB,IAAP,CAAY;AACV2C,aAAO,EACL,wDACAlH,KADA,GAEA,gCAJQ;AAKVmH,UAAI,EAAElJ,wBAAwB,CAAC6M;AALrB,KAAZ;AAOD;;AAED,MACEnM,GAAG,CAACgM,eAAD,EAAkB3K,KAAlB,CAAH,IACArB,GAAG,CAACgM,eAAD,EAAkB5K,YAAlB,CADH,IAEA,CAACpB,GAAG,CAACgM,eAAe,CAACI,KAAjB,EAAwBJ,eAAe,CAACK,WAAxC,CAHN,EAIE;AACAjF,UAAM,CAACxB,IAAP,CAAY;AACV2C,aAAO,EACL,oDAAkDnH,YAAlD,GAA8D,KAA9D,GAAoE4K,eAAe,CAACK,WAApF,GAA+F,GAA/F,GACA,wBAHQ;AAIV7D,UAAI,EACFlJ,wBAAwB,CAACgN;AALjB,KAAZ;AAOD;;AAED,MAAItM,GAAG,CAACgM,eAAD,EAAkB3K,KAAlB,CAAP,EAAiC;AAC/BtB,WAAO,CAACiM,eAAe,CAACI,KAAjB,EAAwB,UAACG,aAAD,EAAgBC,YAAhB,EAA4B;AACzDzM,aAAO,CAACwM,aAAD,EAAgB,UAACrG,WAAD,EAAcuG,OAAd,EAAqB;AAC1C,YAAIlM,WAAW,CAAC2F,WAAD,CAAf,EAA8B;AAC5BkB,gBAAM,CAACxB,IAAP,CAAY;AACV2C,mBAAO,EACL,wEACA,MAAIiE,YAAJ,GAAgB,eAAhB,GAAgCC,OAAhC,GAAuC,KADvC,CAFQ;AAIVjE,gBAAI,EACFlJ,wBAAwB,CAACoN;AALjB,WAAZ;AAOD;AACF,OAVM,CAAP;AAWD,KAZM,CAAP;AAaD;;AAED,SAAOtF,MAAP;AACD;AAED,OAAM,SAAUuF,2BAAV,CACJX,eADI,EAEJC,UAFI,EAGJ/J,wBAHI,EAGyC;AAE7C,MAAM0K,QAAQ,GAAG,EAAjB;AACA,MAAIC,eAAe,GAAG,KAAtB;AACA,MAAMC,aAAa,GAAGvN,OAAO,CAC3BO,OAAO,CAACY,SAAS,CAACsL,eAAe,CAACI,KAAjB,EAAwB,UAACW,QAAD,EAAS;AAAK;AAAQ,GAA9C,CAAV,CADoB,CAA7B;AAIA,MAAMC,kBAAkB,GAAGlM,MAAM,CAC/BgM,aAD+B,EAE/B,UAACtK,QAAD,EAAS;AAAK,mBAAQ,CAACrB,OAAD,CAAR,KAAsB9B,KAAK,CAACoD,EAA5B;AAA8B,GAFb,CAAjC;AAIA,MAAMwK,mBAAmB,GAAGxI,YAAY,CAACvC,wBAAD,CAAxC;;AACA,MAAI+J,UAAJ,EAAgB;AACdlM,WAAO,CAACiN,kBAAD,EAAqB,UAACtI,OAAD,EAAQ;AAClC,UAAMwI,SAAS,GAAGtI,qBAAqB,CAACF,OAAD,EAAUuI,mBAAV,CAAvC;;AACA,UAAIC,SAAS,KAAK,KAAlB,EAAyB;AACvB,YAAM3E,OAAO,GAAG4E,0BAA0B,CAACzI,OAAD,EAAUwI,SAAV,CAA1C;AACA,YAAME,iBAAiB,GAAG;AACxB7E,iBAAO,SADiB;AAExBC,cAAI,EAAE0E,SAAS,CAACG,KAFQ;AAGxBvH,mBAAS,EAAEpB;AAHa,SAA1B;AAKAkI,gBAAQ,CAAChH,IAAT,CAAcwH,iBAAd;AACD,OARD,MAQO;AACL;AACA,YAAIpN,GAAG,CAAC0E,OAAD,EAAU,aAAV,CAAP,EAAiC;AAC/B,cAAIA,OAAO,CAACC,WAAR,KAAwB,IAA5B,EAAkC;AAChCkI,2BAAe,GAAG,IAAlB;AACD;AACF,SAJD,MAIO;AACL,cAAI9L,gBAAgB,CAACkM,mBAAD,EAAsBvI,OAAO,CAACvD,OAA9B,CAApB,EAA4D;AAC1D0L,2BAAe,GAAG,IAAlB;AACD;AACF;AACF;AACF,KAtBM,CAAP;AAuBD;;AAED,MAAIZ,UAAU,IAAI,CAACY,eAAnB,EAAoC;AAClCD,YAAQ,CAAChH,IAAT,CAAc;AACZ2C,aAAO,EACL,qCACA,uEADA,GAEA,kFAFA,GAGA,mFAHA,GAIA,gBANU;AAOZC,UAAI,EAAElJ,wBAAwB,CAACgO;AAPnB,KAAd;AASD;;AACD,SAAOV,QAAP;AACD;AAED,OAAM,SAAUW,gBAAV,CAA2BxI,WAA3B,EAEL;AACC,MAAIyI,YAAY,GAAQ,EAAxB;AACA,MAAIC,SAAS,GAAGjN,IAAI,CAACuE,WAAD,CAApB;AAEAhF,SAAO,CAAC0N,SAAD,EAAY,UAACC,OAAD,EAAQ;AACzB,QAAIC,cAAc,GAAG5I,WAAW,CAAC2I,OAAD,CAAhC;AAEA;;AACA,QAAIxN,OAAO,CAACyN,cAAD,CAAX,EAA6B;AAC3BH,kBAAY,CAACE,OAAD,CAAZ,GAAwB,EAAxB;AACD,KAFD,MAEO;AACL,YAAMnK,KAAK,CAAC,sBAAD,CAAX;AACD;AACF,GATM,CAAP;AAWA,SAAOiK,YAAP;AACD,C,CAED;;AACA,OAAM,SAAUvI,eAAV,CAA0Ba,SAA1B,EAAwC;AAC5C,MAAIR,OAAO,GAAGQ,SAAS,CAAC3E,OAAxB;AACA;;AACA,MAAId,QAAQ,CAACiF,OAAD,CAAZ,EAAuB;AACrB,WAAO,KAAP;AACD,GAFD,MAEO,IAAIlF,UAAU,CAACkF,OAAD,CAAd,EAAyB;AAC9B;AACA,WAAO,IAAP;AACD,GAHM,MAGA,IAAItF,GAAG,CAACsF,OAAD,EAAU,MAAV,CAAP,EAA0B;AAC/B;AACA,WAAO,IAAP;AACD,GAHM,MAGA,IAAIhF,QAAQ,CAACgF,OAAD,CAAZ,EAAuB;AAC5B,WAAO,KAAP;AACD,GAFM,MAEA;AACL,UAAM/B,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;AAED,OAAM,SAAU2B,cAAV,CAAyBI,OAAzB,EAAqC;AACzC,MAAIhF,QAAQ,CAACgF,OAAD,CAAR,IAAqBA,OAAO,CAACvC,MAAR,KAAmB,CAA5C,EAA+C;AAC7C,WAAOuC,OAAO,CAACc,UAAR,CAAmB,CAAnB,CAAP;AACD,GAFD,MAEO;AACL,WAAO,KAAP;AACD;AACF;AAED;;;;AAGA,OAAO,IAAMwH,6BAA6B,GAA2B;AACnE;AACArE,MAAI,EAAE,cAAUsE,IAAV,EAAc;AAClB,QAAIC,GAAG,GAAGD,IAAI,CAAC9K,MAAf;;AACA,SAAK,IAAIgL,CAAC,GAAG,KAAKC,SAAlB,EAA6BD,CAAC,GAAGD,GAAjC,EAAsCC,CAAC,EAAvC,EAA2C;AACzC,UAAIE,CAAC,GAAGJ,IAAI,CAACzH,UAAL,CAAgB2H,CAAhB,CAAR;;AACA,UAAIE,CAAC,KAAK,EAAV,EAAc;AACZ,aAAKD,SAAL,GAAiBD,CAAC,GAAG,CAArB;AACA,eAAO,IAAP;AACD,OAHD,MAGO,IAAIE,CAAC,KAAK,EAAV,EAAc;AACnB,YAAIJ,IAAI,CAACzH,UAAL,CAAgB2H,CAAC,GAAG,CAApB,MAA2B,EAA/B,EAAmC;AACjC,eAAKC,SAAL,GAAiBD,CAAC,GAAG,CAArB;AACD,SAFD,MAEO;AACL,eAAKC,SAAL,GAAiBD,CAAC,GAAG,CAArB;AACD;;AACD,eAAO,IAAP;AACD;AACF;;AACD,WAAO,KAAP;AACD,GAnBkE;AAqBnEC,WAAS,EAAE;AArBwD,CAA9D;;AAwBP,SAASpJ,qBAAT,CACEF,OADF,EAEEF,uBAFF,EAEmC;AASjC,MAAIxE,GAAG,CAAC0E,OAAD,EAAU,aAAV,CAAP,EAAiC;AAC/B;AACA;AACA,WAAO,KAAP;AACD,GAJD,MAIO;AACL;AACA,QAAIrE,QAAQ,CAACqE,OAAO,CAACvD,OAAT,CAAZ,EAA+B;AAC7B,UAAI;AACFJ,wBAAgB,CAACyD,uBAAD,EAA0BE,OAAO,CAACvD,OAAlC,CAAhB;AACD,OAFD,CAEE,OAAOmI,CAAP,EAAU;AACV;AACA,eAAO;AACL+D,eAAK,EAAE/N,wBAAwB,CAAC4O,mBAD3B;AAELC,gBAAM,EAAE7E,CAAC,CAACf;AAFL,SAAP;AAID;;AACD,aAAO,KAAP;AACD,KAXD,MAWO,IAAIjI,QAAQ,CAACoE,OAAO,CAACvD,OAAT,CAAZ,EAA+B;AACpC;AACA,aAAO,KAAP;AACD,KAHM,MAGA,IAAI8D,eAAe,CAACP,OAAD,CAAnB,EAA8B;AACnC;AACA,aAAO;AAAE2I,aAAK,EAAE/N,wBAAwB,CAAC8O;AAAlC,OAAP;AACD,KAHM,MAGA;AACL,YAAM7K,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;AACF;;AAED,OAAM,SAAU4J,0BAAV,CACJzI,OADI,EAEJ2J,OAFI,EAOH;AAED;AACA,MAAIA,OAAO,CAAChB,KAAR,KAAkB/N,wBAAwB,CAAC4O,mBAA/C,EAAoE;AAClE,WACE,qEACA,8BAA4BxJ,OAAO,CAACuC,IAApC,GAAwC,gBADxC,KAEA,oBAAkBoH,OAAO,CAACF,MAA1B,GAAgC,KAFhC,IAGA,qGAJF;AAMD,GAPD,MAOO,IAAIE,OAAO,CAAChB,KAAR,KAAkB/N,wBAAwB,CAAC8O,iBAA/C,EAAkE;AACvE,WACE,gFACA,8BAA4B1J,OAAO,CAACuC,IAApC,GAAwC,gBADxC,IAEA,mGAHF;AAKD,GANM,MAMA;AACL,UAAM1D,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;;AAED,SAASkB,YAAT,CAAsB6J,YAAtB,EAAuD;AACrD,MAAMC,SAAS,GAAG9N,GAAG,CAAC6N,YAAD,EAAe,UAACE,WAAD,EAAY;AAC9C,QAAIlO,QAAQ,CAACkO,WAAD,CAAR,IAAyBA,WAAW,CAACzL,MAAZ,GAAqB,CAAlD,EAAqD;AACnD,aAAOyL,WAAW,CAACpI,UAAZ,CAAuB,CAAvB,CAAP;AACD,KAFD,MAEO;AACL,aAAOoI,WAAP;AACD;AACF,GANoB,CAArB;AAQA,SAAOD,SAAP;AACD;;AAED,SAAShI,gBAAT,CAA0B9F,GAA1B,EAA+BgO,GAA/B,EAAoCC,KAApC,EAAyC;AACvC,MAAIjO,GAAG,CAACgO,GAAD,CAAH,KAAavK,SAAjB,EAA4B;AAC1BzD,OAAG,CAACgO,GAAD,CAAH,GAAW,CAACC,KAAD,CAAX;AACD,GAFD,MAEO;AACLjO,OAAG,CAACgO,GAAD,CAAH,CAAS7I,IAAT,CAAc8I,KAAd;AACD;AACF;;AAED,OAAO,IAAMC,kBAAkB,GAAG,GAA3B;AAEP;;;;;;;;;;;;;;;;AAeA,OAAM,SAAUrI,wBAAV,CAAmCH,QAAnC,EAA2C;AAC/C,SAAOA,QAAQ,GAAGwI,kBAAX,GACHxI,QADG,GAEHyI,yBAAyB,CAACzI,QAAD,CAF7B;AAGD;AAED;;;;;;;;;AAQA,IAAIyI,yBAAyB,GAAG,EAAhC;;AACA,SAAStM,+BAAT,GAAwC;AACtC,MAAInC,OAAO,CAACyO,yBAAD,CAAX,EAAwC;AACtCA,6BAAyB,GAAG,IAAIC,KAAJ,CAAU,KAAV,CAA5B;;AACA,SAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAApB,EAA2BA,CAAC,EAA5B,EAAgC;AAC9B;AACAa,+BAAyB,CAACb,CAAD,CAAzB,GAA+BA,CAAC,GAAG,GAAJ,GAAU,MAAM,CAAC,EAAEA,CAAC,GAAG,GAAN,CAAjB,GAA8BA,CAA7D;AACA;AACD;AACF;AACF","names":["BaseRegExpVisitor","Lexer","LexerDefinitionErrorType","compact","contains","defaults","difference","filter","find","first","flatten","forEach","has","indexOf","isArray","isEmpty","isFunction","isRegExp","isString","isUndefined","keys","map","mapValues","packArray","PRINT_ERROR","reduce","reject","canMatchCharCode","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","getRegExpAst","PATTERN","DEFAULT_MODE","MODES","SUPPORT_STICKY","RegExp","sticky","disableSticky","enableSticky","analyzeTokenTypes","tokenTypes","options","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","msg","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","source","length","ignoreCase","addStickyFlag","addStartOfInput","exec","escapedRegExpString","replace","wrappedRegExp","Error","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdx","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","undefined","longerAltType","LONGER_ALT","longerAltIdx","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","tokType","LINE_BREAKS","checkLineBreaksIssues","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","idx","pattern","longerAlt","canLineTerminator","isCustom","short","group","push","pop","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","result","currTokType","charCode","charCodeAt","optimizedIdx","charCodeToOptimizedIndex","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx_1","charOrInt","currOptimizedIdx","unicode","ensureOptimizations","toString","optimizedCodes","code","name","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","concat","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","message","type","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","__extends","_this","EndAnchorFinder","node","found","invalidRegex","regexpAst","endAnchorVisitor","visit","e","test","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","global","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_a","testTokenType","UNREACHABLE_PATTERN","regExpArray","index","regExp","metaChars","char","flags","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","tokTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","i","lastIndex","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","charCodes","numOrString","key","value","minOptimizationVal","charCodeToOptimizedIdxMap","Array"],"sourceRoot":"","sources":["../../../src/scan/lexer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}