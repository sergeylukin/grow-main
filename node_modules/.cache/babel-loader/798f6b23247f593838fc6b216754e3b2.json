{"ast":null,"code":"import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n} // Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes); // add required tokenType and categoryMatches properties\n\n  assignTokenDefaultProps(tokenTypesAndParents); // fill up the categoryMatches\n\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexport function expandCategories(tokenTypes) {\n  var result = cloneArr(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n\n  while (searching) {\n    categories = compact(flatten(map(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = difference(categories, result);\n    result = result.concat(newCategories);\n\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n\n  return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    } // CATEGORIES? : TokenType | TokenType[]\n\n\n    if (hasCategoriesProperty(currTokType) && !isArray(currTokType.CATEGORIES) // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n  forEach(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode); // avoids infinite loops due to cyclic categories.\n\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexport function hasShortKeyProperty(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n  return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n  return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n  return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}","map":{"version":3,"mappings":"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","names":["cloneArr","compact","contains","difference","flatten","forEach","has","isArray","isEmpty","map","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenTypeIdx","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","token","tokType","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","categoryMatches","length","result","categories","searching","currTokType","CATEGORIES","newCategories","concat","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","val","key","push","singleAssignCategoriesToksMap","path","nextNode","pathNode","nextCategory","newPath","isTokenType"],"sourceRoot":"","sources":["../../../src/scan/tokens.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}