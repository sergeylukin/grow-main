{"ast":null,"code":"import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\n\nvar RestWalker =\n/** @class */\nfunction () {\n  function RestWalker() {}\n\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n\n    forEach(prod.definition, function (subProd, index) {\n      var currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n\n      if (subProd instanceof NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this; // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n\n\n    var fullOrRest = currRest.concat(prevRest); // walk all different alternatives\n\n    forEach(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new Alternative({\n        definition: [alt]\n      });\n\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n\n  return RestWalker;\n}();\n\nexport { RestWalker };\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new Option({\n    definition: [new Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"mappings":"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","names":["drop","forEach","Alternation","Alternative","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","RestWalker","prod","prevRest","definition","subProd","index","currRest","_this","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","Error","terminal","refProd","flatProd","fullOrRest","concat","walk","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","repSepProd","repSepRest","terminalType","separator","fullRepSepRest"],"sourceRoot":"","sources":["../../../../src/parse/grammar/rest.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}