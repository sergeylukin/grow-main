{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, isEmpty, map, reduce, reject } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Alternative as AlternativeGAST, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError));\n}\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nexport function identifyProductionForDuplicates(prod) {\n  return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(GAstVisitor);\n\nexport { OccurrenceValidationCollector };\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n} // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof AlternativeGAST || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(GAstVisitor);\n\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\n\nvar RepetionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetionCollector, _super);\n\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetionCollector;\n}(GAstVisitor);\n\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n\n    return errors;\n  }, []);\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, function (currProd) {\n      var prodType = getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\n\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = []; // flatten\n\n  var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if (contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["utils","contains","every","findAll","flatten","forEach","isEmpty","map","reduce","reject","ParserDefinitionErrorType","getProductionDslName","isOptionalProd","containsPath","getLookaheadPathsForOptionalProd","getLookaheadPathsForOr","getProdType","isStrictPrefixOfPath","nextPossibleTokensAfter","Alternation","Alternative","AlternativeGAST","NonTerminal","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","Terminal","GAstVisitor","validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","currTopLevel","leftRecursionErrors","currTopRule","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","concat","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","groupBy","identifyProductionForDuplicates","duplicates","pick","currGroup","length","errors","values","currDuplicates","firstProd","first","msg","buildDuplicateFoundError","dslName","defError","message","type","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","difference","errorsFromNextSteps","currRefRule","newPath","cloneArr","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","drop","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","dropRight","currErrors","currAlternative","currAltIdx","possibleFirstInAlt","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","compact","validateAmbiguousAlternationAlternatives","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sourceRoot":"","sources":["../../../../src/parse/grammar/checks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}