{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { map, reduce, every, isEmpty, flatten, forEach, has } from \"../../utils/utils\";\nimport { possiblePathsFrom } from \"./interpreter\";\nimport { RestWalker } from \"./rest\";\nimport { tokenStructuredMatcher, tokenStructuredMatcherNoCategories } from \"../../scan/tokens\";\nimport { Alternation, Alternative as AlternativeGAST, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport var PROD_TYPE;\n\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\n\nexport function getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof Option) {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition) {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation) {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\n\nexport function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexport function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = every(alts, function (currAlt) {\n    return every(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  }); // This version takes into account the predicates as well.\n\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = map(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = map(alts, function (currAlt) {\n      return flatten(currAlt);\n    });\n    var choiceToAlt_1 = reduce(singleTokenAlts, function (result, currAlt, idx) {\n      forEach(currAlt, function (currTokType) {\n        if (!has(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          if (!has(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, []);\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  }\n}\nexport function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = every(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length; // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = flatten(alt);\n\n    if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = reduce(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        } // found a full path that matches.\n\n\n        return true;\n      } // none of the paths matched\n\n\n      return false;\n    };\n  }\n}\n\nvar RestDefinitionFinderWalker =\n/** @class */\nfunction (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    } // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n\n\n    return false;\n  };\n\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return RestDefinitionFinderWalker;\n}(RestWalker);\n/**\n * Returns the definition of a target production in a top level level rule.\n */\n\n\nvar InsideDefinitionFinderVisitor =\n/** @class */\nfunction (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n\n  return InsideDefinitionFinderVisitor;\n}(GAstVisitor);\n\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n\n  return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\n\n\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n\n    keys = longerKeys;\n  }\n\n  return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\n\n\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  } // None of the SearchPathKeys were found in any of the other alternatives\n\n\n  return true;\n}\n\nexport function lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = map(altsDefs, function (currAlt) {\n    return possiblePathsFrom([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = map(partialAlts, function (currAltPaths) {\n    var dict = {};\n    forEach(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      forEach(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts; // maxLookahead loop\n\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n\n    var _loop_1 = function _loop_1(altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx]; // paths in current alternative loop\n\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx); // End of the line for this path.\n\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx]; // TODO: Can we implement a containsPath using Maps/Dictionaries?\n\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix); // Update all new  keys for the current path.\n\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes); // Update keys for new known paths\n\n          forEach(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }; // alternatives loop\n\n\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n\n  return finalResult;\n}\nexport function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexport function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new AlternativeGAST({\n    definition: insideDef\n  });\n  var afterFlat = new AlternativeGAST({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexport function containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\nexport function isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nexport function areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every(lookAheadPaths, function (singleAltPaths) {\n    return every(singleAltPaths, function (singlePath) {\n      return every(singlePath, function (token) {\n        return isEmpty(token.categoryMatches);\n      });\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["map","reduce","every","isEmpty","flatten","forEach","has","possiblePathsFrom","RestWalker","tokenStructuredMatcher","tokenStructuredMatcherNoCategories","Alternation","Alternative","AlternativeGAST","Option","Repetition","RepetitionMandatory","RepetitionMandatoryWithSeparator","RepetitionWithSeparator","GAstVisitor","PROD_TYPE","getProdType","prod","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","Error","buildLookaheadFuncForOr","occurrence","ruleGrammar","maxLookahead","hasPredicates","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","tokenMatcher","areTokenCategoriesNotUsed","buildLookaheadFuncForOptionalProd","k","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","numOfAlts","length","areAllOneTokenLookahead","currAlt","currPath","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","undefined","call","nextPath","j","currPathLength","i","nextToken","LA","singleTokenAlts","choiceToAlt_1","result","idx","currTokType","tokenTypeIdx","categoryMatches","currExtendingType","buildSingleAlternativeLookaheadFunction","alt","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey_1","choiceToAlt_2","__extends","topProd","targetOccurrence","targetProdType","_super","_this","RestDefinitionFinderWalker","walk","restDef","node","expectedProdType","currRest","prevRest","concat","optionProd","checkIsTarget","walkOption","atLeastOneProd","atLeastOneSepProd","manyProd","manySepProd","targetRef","InsideDefinitionFinderVisitor","expectedProdName","definition","initializeArrayOfArrays","size","Array","pathToHashKeys","path","keys","tokType","longerKeys","currShorterKey","push","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","currAltPaths","dict","item","partialPath","currKey","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","suffixDef","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","key","orProd","visitor","accept","insideDefVisitor","insideDef","afterDefWalker","afterDef","startWalking","insideFlat","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","categoryMatchesMap","isStrictPrefixOfPath","prefix","other","otherTokType","singleAltPaths","singlePath","token"],"sourceRoot":"","sources":["../../../../src/parse/grammar/lookahead.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}